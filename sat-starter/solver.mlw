module Solver

use int.Int
use ref.Ref
use list.List
use list.Length as List
use list.Mem
use list.Append
use array.Array
use array.ArrayEq
use option.Option

use SatDefs (* From sat_base.mlw *)
use ResolutionProof (* From resolution.mlw *)

(******************************************************************************)
(* Routines for managing solver state                                         *)
(******************************************************************************)

let rec backtrack (diff : list var) (pval : pval) =
  () (* Implement this function *)

exception Sat_found

let rec set_sign (l : lit) (pval : pval) (cnf : cnf) : (bool, option clause, list var) =
  (false, None, Nil) (* Implement this function *)


(******************************************************************************)
(* Main algorithm                                                             *)
(******************************************************************************)

(*
  You should not change the following type for the checkpoint.
  For the final submission, you should change
    `Assignment valuation`
  to
    `Assignment pval`
*)
type solver_result =
  | Assignment valuation
  | Proof certificate

(*define a type for producing certificate*)
type certChain =
  | Chain certificate
  | Empty   (*Help distinguish where nothing is found yet*)

exception Sat
exception InvalidCert


let rec valid_counter_clause (c : clause) (rho : valuation) (lit : lit) =
    match c with
        | Nil -> true
        | Cons l ls -> (if l.var > lit.var then false 
                       else 
                        (if l.var = lit.var then 
                            (if lit.sign = l.sign then false
                            else valid_counter_clause ls rho lit )
                         else 
                            (if rho[l.var] = l.sign then false
                            else valid_counter_clause ls rho lit ) ) )
    end

let search_for_ref (rho : valuation) (cnf : cnf) (lit : lit): certChain =
    let ref i = 0 in
    let ref res = Empty in
    while i < (length cnf.clauses)
    do
        (*check if current clause satisfies conflict*)
        if (var_in_clause lit cnf[i] && valid_counter_clause cnf[i] rho lit)
        then res <- Chain (Assume cnf[i]) ; i <- length cnf.clauses
        else i <- i+1
    done;
    res

let get_unit_ref (rho : rho) (cnf : cnf) (lit : lit) (prev : certChain) : certChain =
    match prev with
        | Empty -> (search_for_ref rho cnf lit)
        | _ -> prev
    end

let rec clause_combine_except (cl : clause) (var: var) : clause =
    match cl with 
        | Nil -> Nil
        | Cons x xs -> (let newCl = (clause_combine_except xs var ) in
                if mem x newCl then newCl else 
                    (if x.var = var then newCl else (Cons x newCl) )
                end)
    end

let apply_resolution (cert1: certificate) (cert2: certificate) (var : var) : certChain =
    (*must have true var on left and false on right*)
    let ref cl1 = Nil in
    let ref cl2 = Nil in
    match (cert1, cert2) with
        | (Assume clause1, Assume clause2) ->
            cl1 <- clause1 ; cl2 <-clause2
        | (Resolve _ _ _ clause1, Assume clause2) ->
            cl1 <- clause1 ; cl2 <-clause2
        | (Assume clause1, Resolve _ _ _ clause2) -> 
            cl1 <- clause1 ; cl2 <-clause2
        | (Resolve _ _ _ clause1, Resolve _ _ _ clause2) ->
            cl1 <- clause1 ; cl2 <-clause2 
    end;
    if ( var_in_clause var cl1 && var_in_clause var cl2 ) then 
       Chain Resolve cert1 cert2 ( clause_combine_except (cl1 ++ cl2) var )
    else
       Chain cert1  (*choose left naively: left right should be same (only difference is in 
                     the )*)



let sat (cnf : cnf) : solver_result =
  ensures { forall t. result = Assignment t -> sat_with t cnf }     (* DO NOT CHANGE *)
  ensures { forall p. result = Proof p -> valid_refutation p cnf }  (* DO NOT CHANGE *)
  raises  { InvalidCert }

  let t = make cnf.nvars false in 
  let rec split i : certChain =
    variant  { cnf.nvars - i }
    requires { 0 <= i <= cnf.nvars }
    ensures  { array_eq_sub (old t) t 0 i }
    raises   { Sat -> sat_with t cnf }

    if i = cnf.nvars then begin
      if eval_cnf t cnf then raise Sat else Empty
    end
    else begin
      let ref left = Empty in
      let ref right = Empty in
      t[i] <- false ; left <- split (i + 1) ;
      t[i] <- true  ; right <- split (i + 1) ;
      (*Conflict reached, attempt to generate cert*)
      let ref procLeft = get_unit_ref t cnf ({var=i ;sign=false }) left in
      let ref procRight = get_unit_ref t cnf ({var=i ;sign=true }) right in
      match (procLeft, procRight) with
        | (Empty, Empty) -> Empty
        | (Empty, _) -> procRight
        | (_, Empty) -> procLeft  
        | (Chain cert1, Chain cert2) -> (apply_resolution cert1 cert2 i) (**)
        end 
    end
  in try ( match split 0 with 
        | Empty -> raise InvalidCert
        | Chain cert -> if (check_refutation cert) then ({Proof cert}) else raise InvalidCert
        end )
    with Sat -> Assignment t end

end (* Solver *)