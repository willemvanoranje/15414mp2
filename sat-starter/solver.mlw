
module Solver

use int.Int
use ref.Ref
use list.List
use list.Length as List
use list.Mem
use list.Append
use array.Array
use array.ArrayEq
use option.Option



use SatDefs (* From sat_base.mlw *)
use ResolutionProof (* From resolution.mlw *)



(*Types and shared helper functions*)

(*define a type for producing certificate*)
type certChain =
  | Chain certificate
  | Empty   (*Help distinguish where nothing is found yet*)

let extract_sat_valuation (pval : pval) (cnf : cnf) : valuation =
  requires { valid_pval pval cnf }
  requires { sat_with_pval pval cnf }
  ensures  { sat_with result cnf }

  let rho = Array.make (length pval) false in
  for i = 0 to length pval - 1 do
    invariant { forall j:int, b:bool.
      0 <= j < i -> pval[j] = Some b -> rho[j] = b }
    match pval[i] with
    | None -> ()
    | Some v -> rho[i] <- v
    end
  done ;
  assert { compatible pval rho } ;
  rho

let rec clause_combine_except (cl : clause) (v: var) : clause =
    match cl with 
        | Nil -> Nil
        | Cons x xs -> (let newCl = (clause_combine_except xs v ) in
                if (lit_in_clause x newCl) then newCl else 
                    (if (x.var = v) then newCl else (Cons x newCl) ) )
    end

let rec valid_counter_clause (c : clause) (rho : valuation) (lit : lit) : bool =
    requires{vars_in_range rho.length c}
    diverges
    match c with
        | Nil -> true
        | Cons l ls -> (if l.var > lit.var then false 
                       else 
                        (if (l.var = lit.var) then 
                            (if (bool_eq l.sign lit.sign) then false
                            else (valid_counter_clause ls rho lit ))
                         else 
                            (if (bool_eq rho[l.var] l.sign) then false
                            else (valid_counter_clause ls rho lit ) ) ) )
    end

let rec search_for_ref (rho : valuation) (cnf : cnf) (lit : lit) (i : int) : certChain =
    
    if ( i < (length cnf.clauses) ) then
        (*check if current clause satisfies conflict*)
        ( if ( (var_in_clause lit.var cnf.clauses[i]) && (valid_counter_clause cnf.clauses[i] rho lit) )
         then ( Chain (Assume cnf.clauses[i]) )
         else (search_for_ref rho cnf lit (i+1)) )
    else Empty

let get_unit_ref (rho : valuation) (cnf : cnf) (lit : lit) (prev : certChain) : certChain =
    match prev with
        | Empty -> (search_for_ref rho cnf lit 0)
        | _ -> prev
    end


let apply_resolution (cert1: certificate) (cert2: certificate) (var : var) : certChain =
    (*must have true var on left and false on right*)
    let ref cl1 = Nil in
    let ref cl2 = Nil in
    match (cert1, cert2) with
        | (Assume clause1, Assume clause2) ->
            cl1 <- clause1 ; cl2 <-clause2
        | (Resolve _ _ _ clause1, Assume clause2) ->
            cl1 <- clause1 ; cl2 <-clause2
        | (Assume clause1, Resolve _ _ _ clause2) -> 
            cl1 <- clause1 ; cl2 <-clause2
        | (Resolve _ _ _ clause1, Resolve _ _ _ clause2) ->
            cl1 <- clause1 ; cl2 <-clause2 
    end;
    if ( var_in_clause var cl1 ) then 
       ( 
         if ( var_in_clause var cl2 ) then 
            Chain (Resolve cert1 cert2 var ( clause_combine_except (cl1 ++ cl2) var )) 
         else 
            Chain cert2 (*avoid term with clause if clause is irrelevant*)
        )
    else (
          if ( var_in_clause var cl2 ) then 
            Chain cert1
         else 
            Chain cert1 (*Does not appear in both, then both trees must have same structure,
                  Thus producing the exact same result*)
        )



(******************************************************************************)
(* Routines for managing solver state                                         *)
(******************************************************************************)


let rec backtrack (diff : list var) (pval : pval) =
  match diff with 
  | Nil -> ()
  | Cons x xs -> ( pval[x] <- None ; backtrack xs pval )
  end

exception Sat_found

let rec get_conflict_clause (pval : pval) (cnf : cnf) : clause =
  let ref conflictC = Nil in
  let ref i = 0 in
  while i < cnf.clauses.length do 
      match partial_eval_clause pval cnf.clauses[i] with
        | Satisfied -> ( i <- i + 1 )
        | Conflicting -> ( conflictC <- cnf.clauses[i] ; i <- cnf.clauses.length )
        | Unit lit -> ( i <- i + 1 )
        | Unresolved -> ( i <- i + 1 )
      end;
  done ;
  conflictC

let rec get_unit_clause (l : lit) (pval : pval) (cnf : cnf) : clause =
  let ref unitC = Nil in
  let ref i = 0 in
  while i < cnf.clauses.length do 
      match partial_eval_clause pval cnf.clauses[i] with
        | Satisfied -> ( i <- i + 1 )
        | Conflicting -> ( i <- i + 1 ) (*what happens here?*)
        | Unit lit -> (
            if (l.var = lit.var && l.sign == lit.sign) then 
                ( unitC <- cnf.clauses[i] ; i <- cnf.clauses.length )
            else ( i <- i + 1 ) 
            )
        | Unresolved -> ( i <- i + 1 )
      end;
  done ;
  unitC



(*Modified the return result to give out a refutation chain instead*)
let rec set_sign (l : lit) (pval : pval) (cnf : cnf) : (bool, certChain, list var) =
  pval[l.var] <- Some (l.sign);
  try ( match partial_eval_cnf pval cnf with
          | Sat -> Raise Sat_found
          | Other -> ( false, Empty , Cons l.var Nil )
        end
      )
  with
    | Conflict_found -> ( true, Chain (Assume (get_conflict_clause pval cnf)), Cons l.var Nil )
    | Unit_found newLit -> 
        (
          match (set_sign newLit pval cnf) with
            | (false, _, listV ) -> (false, Empty, Cons l.var listV )
            | (true, Empty , listV ) -> ( true, Empty, Cons l.var listV)
            | (true, Chain cert1, listV) ->
              (true , (apply_resolution cert1 (get_unit_clause newLit pval cnf) newLit.var), Cons l.var listV)
          end 
        )
  end



(******************************************************************************)
(* Main algorithm                                                             *)
(******************************************************************************)

(*
  You should not change the following type for the checkpoint.
  For the final submission, you should change
    `Assignment valuation`
  to
    `Assignment pval`
*)
type solver_result =
  | Assignment valuation
  | Proof certificate


exception Sat
exception InvalidCert

let find_next_unassigned (v : var) (pval : pval) : var =
  let ref ans = pval.length in
  let ref i = v in
  while i < pval.length do 
    match pval[v] with
      | None -> (res <- ans; i <- pval.length )
      | Some _ -> (i <- i+1 )
    end;
  done;
  ans

let sat (cnf : cnf) : solver_result =
  ensures { forall t. result = Assignment t -> sat_with t cnf }     (* DO NOT CHANGE *)
  ensures { forall p. result = Proof p -> valid_refutation p cnf }  (* DO NOT CHANGE *)
  diverges 
  raises  { InvalidCert }

  let p = make cnf.nvars None in 
  let rec split i : certChain =
    variant  { cnf.nvars - i }
    requires { 0 <= i <= cnf.nvars }
    raises   { Sat_found -> sat_with_pval p cnf }

    if i = cnf.nvars then Empty (*We should never reach here*)
    else begin
      match ( set_sign ({var = i, sign = false}) p cnf ) with
        | (false, _, listVL) -> (
                let ref leftCert = split (find_next_unassigned i pval) in
                  backtrack listVL pval; (*revert changes and try right side *)
                  match ( set_sign ({var = i, sign = true}) p cnf ) with
                    | (false, _ , listVR) -> ( 
                        let ref rightCert = split (find_next_unassigned i pval) in
                          (apply_resolution leftCert rightCert i)
                        )
                    | (true, rightCert , _ ) -> ( apply_resolution leftCert rightCert i )
                  end
                )     
        | (true, leftCert, listVL ) -> (
                backtrack listVL pval; (*revert changes and try right side *)
                match ( set_sign ({var = i, sign = true}) p cnf ) with
                    | (false, _ , listVR) -> ( 
                        let ref rightCert = split (find_next_unassigned i pval) in
                          (apply_resolution leftCert rightCert i)
                        )
                    | (true, rightCert , _ ) -> ( apply_resolution leftCert rightCert i )
                end
                )
    end

  in try ( match split 0 with 
        | Empty -> raise InvalidCert
        | Chain cert -> if (check_refutation cert cnf) then (Proof cert) else raise InvalidCert
        end )
    with Sat_found ->  Assignment ( extract_sat_valuation p cnf) end


(*Orignial Baby sat kept for reference*)
(*
let sat (cnf : cnf) : solver_result =
  ensures { forall t. result = Assignment t -> sat_with t cnf }     (* DO NOT CHANGE *)
  ensures { forall p. result = Proof p -> valid_refutation p cnf }  (* DO NOT CHANGE *)
  diverges 
  raises  { InvalidCert }

  let t = make cnf.nvars false in 
  let rec split i : certChain =
    variant  { cnf.nvars - i }
    requires { 0 <= i <= cnf.nvars }
    ensures  { array_eq_sub (old t) t 0 i }
    raises   { Sat -> sat_with t cnf }

    if i = cnf.nvars then begin
      if eval_cnf t cnf then raise Sat else Empty
    end
    else begin
      let ref left = Empty in
      let ref right = Empty in
      t[i] <- false ; left <- split (i + 1) ;
      t[i] <- true  ; right <- split (i + 1) ;
      (*Conflict reached, attempt to generate cert*)
      let ref procLeft = get_unit_ref t cnf ({var=i ;sign=false }) left in
      let ref procRight = get_unit_ref t cnf ({var=i ;sign=true }) right in
      match (procLeft, procRight) with
        | (Empty, Empty) -> Empty
        | (Empty, _) -> procRight
        | (_, Empty) -> procLeft  
        | (Chain cert1, Chain cert2) -> (apply_resolution cert1 cert2 i) (**)
        end 
    end
  in try ( match split 0 with 
        | Empty -> raise InvalidCert
        | Chain cert -> if (check_refutation cert cnf) then (Proof cert) else raise InvalidCert
        end )
    with Sat -> Assignment t end
*)


end (* Solver *)
